# January 19, 2024 - Fixing Undefined Behavior

![Finally. IT's done](../../img/ramblings/2024/its_done.jpg)

So what's this all about? Well, Rustic has had a dirty little secret since
its very first Alpha 1 version: despite using safe Rust being a top
priority for the engine, Rustic has had a little bit of unsafe code tucked
away in a dark corner somewhere. That in itself isn't that big of a deal,
but in this case, this unsafe code expected a certain outcome, where Rust
defines this outcome as undefined behavior. That's bad.

Why? Because it isn't called "Undefined Behavior" for nothing. It means
that you're depending on a behavior of which the compiler deems that it
should not exist. This can cause trouble with newer versions of the
compiler, or when enabling optimizations.

People coming from C or C++ may already recognize this. You may have been
in this situation yourself. For example, have you ever encountered the
weird problem that a program suddenly doesn't work right, when turning on
the -O2 or -O3 optimizations in GCC, while it _does_ work as expected when
leaving out or only basic optimization? That happens when the program
depends on a characteristic of the non-optimized compile, which changes
when optimizations are turned on at a certain level. That's why it's called
"undefined behavior." I also know of a at least one chess engine that is
being developed and compiled with a very old version of GCC, because newer
versions fixed an undefined behavior the engine depends upon; in other
words, when compiling that engine with newer versions of GCC, it won't work
right.

Where did Rustic suffer from this? The problem was in the move list. When
first developing Rustic, it was very slow compared to what I was expecting.
After profiling and researching, the problem turned out to be in the
creation of the move list. It is best to create a move list in an array,
backed by a counter, as compared to just using a vector. The reason is that
an array is created on the stack, while a vector lives on the heap. The
array is faster to set up. However, Rust requires that all variables need
to be initialized before they are used. Therefore, when creating an array
to hold 255 moves, Rust declares the memory and writes a 0 into each
location. After that, the move generator runs, it will be overwriting 30 or
40 zero's, so it is doing lots of double work.

The solution is to get Rust to create the array without initializing it. My
first attempt in Rustic Alpha 1 looked like this:

